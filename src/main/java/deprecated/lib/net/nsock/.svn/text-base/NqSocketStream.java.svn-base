package _sst.net.netqueue2;

import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import _sst.util.TimeUtil;
import _sst.debug.MyDebug;

import _sst.net.net_common;
import _sst.lang.ThreadX;



/**
 *
 * <p>Title: </p>
 *
 * <p>Description: </p>
 *
 * <p>Copyright: Copyright (c) 2007</p>
 *
 * <p>Company: </p>
 *
 * @author not attributable
 * @version 1.0
 */
class ReturnReserveStruct {
    public ReturnReserveStruct() {
    }

    public int usable = 0;
    public int send_number = 0;
    public Socket sk = null;
    public TimeUtil tu = new TimeUtil(); //reset timer
}


/**
 *
 * <p>Title: </p>
 *
 * <p>Description: </p>
 *
 * <p>Copyright: Copyright (c) 2007</p>
 *
 * <p>Company: </p>
 *
 * @author not attributable
 * @version 1.0
 */
class NqSocketStream extends net_common {

    public NqSocketStream() {
        //
        setReturnBufferOnSender(null, 0);
        r_init();
        //vals
        m_max_buffer_size = 1024*8;//256k
        m_send_number = 0;
        m_resend_interval = (int) (1.5 * 1000); //1.5 second
    }


    //initialize to recv buf...
    void r_init() {
        m_r_data.sending_number = 0;
        setReturnValue(null, 0);
    }


//conf
    public int m_max_buffer_size;
    private long m_resend_interval;


//std_send
    protected Object m_syncSendLock = new Object();
    protected int m_isReceivedReturnVal;
    protected NqStreamPacketHeader m_s_e_sval = new NqStreamPacketHeader();
    protected int m_send_number; //a section..

//recv
    protected Object m_syncRecvLock = new Object();
    protected NqStreamPacketHeader m_r_data = new NqStreamPacketHeader();
    private ArrayList<Integer> m_receivedNumbers = new ArrayList<Integer>();

    //relate return
    NqByteBufferWrap m_returnBufOnReceiver = new NqByteBufferWrap();
    int m_returnBufferLenOnReceiver;


    //return:receiver
    Object m_returnBufferLock = new Object();
    //return:sender
    byte[] m_returnBufOnSender;
    int m_returnBufLenOnSender;
    int m_returnBufReceivedSize;







    /**
     *
     * @param buf byte[]
     * @param s int
     * @return int
     */
    protected int setReturnBufferOnSender(byte[] buf, int s) {
        synchronized (m_returnBufferLock) {

            m_returnBufLenOnSender = s;
            if (s == 0)
                return 0;

            m_returnBufOnSender = buf;
            m_returnBufLenOnSender = s;
            return s;
        }
    }

    /**
     *
     * @param buf byte[]
     * @param s int
     * @return int
     */
    protected int copyReturnValueOnSender(byte[] buf, int s) {
        synchronized (m_returnBufferLock) {
            if (m_returnBufOnSender == null || m_returnBufLenOnSender == 0)
                return 0;

            int cl = Math.min(s, m_returnBufLenOnSender);

            //System.out.println("c r v : "+ m_returnBufOnSender.length + "   "+ buf.length +"  "+ cl );

            memcpy(m_returnBufOnSender, buf, cl);

            m_returnBufReceivedSize = s;

            m_returnBufLenOnSender = 0; //not recevie more datas
            //m_returnBufOnSender[cl]=0;

            return cl;
        }
    }


    /**
     *
     * @param buf byte[]
     * @param s int
     * @return int
     */




    protected ReturnReserveStruct m_for_reserve_response = new ReturnReserveStruct();


    synchronized int setReturnValue(byte[] buf, int s) {
        synchronized (m_returnBufferLock) {

            //check: max buffer size
            if (s > this.m_max_buffer_size) {
                //FileLog::prt("result buffer size over (%d/%d) ", s,                                 m_max_buffer_size);
                m_returnBufferLenOnReceiver = 0;
                return 0;
            }

            m_returnBufferLenOnReceiver = s;
            if (s == 0)
                return 0;

            m_returnBufOnReceiver.realloc(s + 1);
            memcpy(m_returnBufOnReceiver.buf, buf, s); //copy

            m_returnBufOnReceiver.buf[s] = 0;

            if (
                    m_for_reserve_response.usable == 1 &&
                    m_for_reserve_response.send_number == m_r_data.sending_number
                    ) {


                 sendResponse(m_for_reserve_response.sk, 3, m_r_data.sending_number, m_returnBufOnReceiver.buf,
                              m_returnBufferLenOnReceiver);

                //init
                m_for_reserve_response.usable = 0;
                m_for_reserve_response.send_number = 0;
            }

            return s;
        }
    }


//
//  NqSocketStream::sendStream
//
// -2 /return buffer length over error of client
// -1 socket error
//  0 error / socket error
//  bigger then zero -  std_send success (returned data size)
//

    int sendStream
            (
                    Socket sk,

                    byte[] sndBuf,
                    int sndLen,

                    byte[] recvBuf,
                    int recvLen,

                    long time_out
            ) {
        //debug("sendstream");

        synchronized (m_syncSendLock) {

            //init return buf
            m_returnBufOnSender = null;
            m_returnBufLenOnSender = 0;

            setReturnBufferOnSender(recvBuf, recvLen);
            ByteArrayOutputStream sbuffer_bos = new ByteArrayOutputStream();
            DataOutputStream sbuffer = new DataOutputStream(sbuffer_bos);

            //recv events
            m_isReceivedReturnVal = 0;
            m_returnBufReceivedSize = 0;

            //sending number
            m_send_number++;
            int sending_number = m_send_number; //copy to local

            //set local variables
            int resend_start = 0;
            TimeUtil resend_time = new TimeUtil();
            TimeUtil wait_time = new TimeUtil();
            //NqStreamPacketHeader data_st = new NqStreamPacketHeader(); //data unit
            int s_step = 0; //std_send step

            long startSendTime = System.currentTimeMillis();

            //run: step 2
            //debug("step-2");
            s_step = 2;



            wait_time.start();

            resend_start = 1;
            resend_time.start();

            byte[]reserve1=new byte[]{0,0,0,0};
            byte[] s1sbuf = NqStreamPacketHeader.writeBytes("ulib-ng", sndBuf, sndLen, sending_number, reserve1);

            while (s_step == 2) {

                if (
                        resend_start == 1 ||
                        (int) (resend_time.end() * 1000) > m_resend_interval*3) {

                    int r1 = net_common.std_send(sk, s1sbuf, s1sbuf.length, 0);

                    if (r1 == 0 || r1 == -1) {
                        return r1;
                    }

                    resend_time.start();
                    resend_start = 0;
                }

                ThreadX.sleep(10);

                if (m_isReceivedReturnVal == 1) {
                    m_isReceivedReturnVal = 0;

                    wait_time.start(); //timer reset
                    //System.out.println("on here:~~~ "+ sending_number +"  "+ m_s_e_sval.sending_number);
                    //wait
                    if (sending_number == m_s_e_sval.sending_number) {
                        this.m_resend_interval=(System.currentTimeMillis() - startSendTime);

                        if( m_returnBufReceivedSize >recvLen) {
                            return -20;//return buffer over!
                        }
                        //debug("std_send step 2: " + (double) (System.currentTimeMillis() - ss1) / 1000.0);
                        return m_returnBufReceivedSize; //return: success
                    }
                }

                if ((long) (wait_time.end() * 1000) > time_out) {
                    return 0;
                }

            } //while

            //debug("std_send step 2 err: " + (double) (System.currentTimeMillis() - ss1) / 1000.0);
            //ss1 = System.currentTimeMillis();
            //if (true)
            //    return 0;

            //debug("sendstream-end");
            return 0; //return : fail

        } //sync
    }


    /**
     *
     * @param sk Socket
     * @param step int
     * @param dd NqStreamPacketHeader
     * @param bufData byte[]
     * @param bufLen int
     * @return int
     */
    int sendResponse(Socket sk, int step, int sn, byte[] bufData, int bufLen) {

        byte[]reserve1=new byte[]{'r',0,0,0};
        byte[] bs = NqStreamPacketHeader.writeBytes("ulib-nr", bufData, bufLen, sn,reserve1);
        //return NqCommonDef.sendData(sk, bs, bs.length);
        return net_common.std_send(sk, bs, bs.length, 0);

    }


// -1 socket error
//  0 error / socket error
//  1 get a stream data
//

    TimeUtil tux = new TimeUtil();
    synchronized int recvStream(Socket sk, byte[] bufData, int bufLen, NqEventClass in_out_val) {
        //debug("recvStream");

        synchronized (m_syncRecvLock) {

            in_out_val.len = 0;
            in_out_val.msg = "";
            in_out_val.sk = sk;

            //check: buf length
            if (bufLen < NqStreamPacketHeader.headSize() * 2)
                return 0;

            NqStreamPacketHeader data_st = new NqStreamPacketHeader();

            if (data_st.readBytes("ulib-ng", bufData, bufLen) >= 0) {

                //is recevied?
                for (int i = 0; i < m_receivedNumbers.size(); i++) {
                    Integer it = (Integer) m_receivedNumbers.get(i);
                    if (it.intValue() == data_st.sending_number) {
                        debug("pass sn:" + data_st.sending_number);
                        return 0; //already received
                    }
                }

                if (
                        m_for_reserve_response.usable == 0
                        ) {

                    r_init();
                    m_r_data.sending_number = data_st.sending_number;

                    if (m_max_buffer_size < data_st.buffer.length) {
                        MyDebug.prt(">sock stream.step 1 err.size(%d)(%d)", m_max_buffer_size, data_st.buffer.length);
                        r_init();
                        return 0;
                    }

                    {
                        in_out_val.msg = "step2-done";
                        in_out_val.copyBuf(data_st.buffer, data_st.buffer.length);
                        in_out_val.sn = m_r_data.sending_number;
                    }

                    m_receivedNumbers.add(new Integer(data_st.sending_number));
                    if (m_receivedNumbers.size() > 100) {
                        m_receivedNumbers.remove(0);
                    }
                    //}

                    //for reponse performance
                    m_for_reserve_response.usable = 1;
                    m_for_reserve_response.send_number = m_r_data.sending_number;
                    m_for_reserve_response.sk = sk;
                    m_for_reserve_response.tu.start();

                    tux.start();
                    return data_st.buffer.length;

                    //}

                } else {

                }
            }

            //
            //recv: r -> s
            //
            //
            if (data_st.readBytes("ulib-nr", bufData, bufLen) >= 0 && data_st.sending_number == this.m_send_number) {

                if (data_st.buffer.length>0 && data_st.reserve1[0]=='r') {

                    if (m_returnBufReceivedSize == 0) {
                        //byte[] bu = bufferM(bufData, data_st.buffer.length);
                        //copyReturnValueOnSender(bu, data_st.buffer.length);
                        copyReturnValueOnSender(data_st.buffer, data_st.buffer.length);
                    }

                    //m_s_e_sval.writeBytes("ulib-nr", data_st.buffer, data_st.buffer.length, data_st.sending_number);

                    m_s_e_sval.buffer = data_st.buffer;
                    m_s_e_sval.sending_number = data_st.sending_number;

                    m_isReceivedReturnVal = 1;
                } else {
                    //System.out.println("ignore to 0 length data");
                }
            } //if("pt-r-01" )

            return 0;
        } //sync
    } //method

} //class
