package _sst.net.netqueue2;

import java.util.Arrays;
import java.net.Socket;
import java.util.ArrayList;
import _sst.net.*;
import _sst.lang.ustring;
import _sst.lang.ThreadX;
import _sst.cplusplus.std_stream2;
import _sst.util.ByteArrayUtil;


/**
 *
 * <p>Title: </p>
 *
 * <p>Description: </p>
 *
 * <p>Copyright: Copyright (c) 2007</p>
 *
 * <p>Company: </p>
 *
 * @author not attributable
 * @version 1.0
 */
interface ServerSocketInterface {
    public int event_recv_Cs(Object cls, Socket sk, byte[] buf, int len);
}


/**
 *
 * <p>Title: </p>
 *
 * <p>Description: </p>
 *
 * <p>Copyright: Copyright (c) 2007</p>
 *
 * <p>Company: </p>
 *
 * @author not attributable
 * @version 1.0
 */
class ClientSocket extends NqThreadX {

    public ClientSocket(String name) {
        m_interface = null;
        m_break = 0;
        m_close_reserve = 0;
        m_max_buffer_size = 1024*8;//8k
        m_name = name;
    }


    public wsocket m_ss = new wsocket();
    public int m_break;
    public ServerSocketInterface m_interface = null;
    public int m_close_reserve;
    public int m_max_buffer_size;
    public String m_name = "";
    //for time out






    NqSocketStream m_sscls = new NqSocketStream();







    public void run2() {
        //char *buf=new char[m_max_buffer_size+1];

        NqStreamPacketHeader nqph=new NqStreamPacketHeader();
        std_stream2 recvCollectBuf = new std_stream2();




        m_sscls.m_max_buffer_size = m_max_buffer_size;

        //System.out.println("clientsocket mb-1:"+m_max_buffer_size);
        Socket sk = m_ss.getHandle();
        NqByteBufferWrap sbuf = new NqByteBufferWrap(m_max_buffer_size + 1);
        while (m_break == 0) {

            sbuf.buf[0] = 0;
            int r = net_common.std_recv(m_ss.getHandle(), sbuf.buf, m_max_buffer_size);
            //System.out.println("recv: ------------------------------"+r );



            if (r == 0) {
                //closesocket(sk);
                //m_close_reserve = 1;
                //return;
                //fail
            } else if (r == -1) {
                //socket error
                closesocket(sk);
                m_close_reserve = 1;
                //delete[] buf;
                return;
            } else if (r > 0) {

                //System.out.println( "svr recv : "+ r +"     "+ recvCollectBuf.length());

                //*** collect to double data.... it error!!!!
                if (recvCollectBuf.length() > m_max_buffer_size*2 ) {
                    System.out.println("recv size over : "+ recvCollectBuf.length() +" > "+ (m_max_buffer_size ));
                    recvCollectBuf.reset();
                }
                recvCollectBuf.writeBytes(sbuf.buf, r);


                int work=0;
                do {
                    work=0;


                    if (nqph.rightPacket(recvCollectBuf.buf(), recvCollectBuf.length()) == 0) {
                        recvCollectBuf.reset();//check to packet format
                    } else {
                        int n = nqph.checkBytes(recvCollectBuf.buf(), recvCollectBuf.length());
                        if( n>0) {
                            //System.out.println("recv chk:"  + n);

                            byte[] rb =  Arrays.copyOfRange( recvCollectBuf.buf(), 0, n );
                            recvCollectBuf.moveToFront(n);

                            //System.out.println("recv chk:"  + new String(rb) );

                            //general recv
                            if (m_interface != null) {
                                m_interface.event_recv_Cs(this, m_ss.getHandle(), rb, rb.length );
                            }
                            //recvCollectBuf.reset();
                            work = 1;
                        }//if( n>0) {


                    }//else

                } while (work == 1);

            }
            ThreadX.sleep(1);
        } //while

        closesocket(sk);
        m_close_reserve = 1;
        //delete[] buf;
    }

    void cleanUp() {
        if (m_ss.alive() == false)
            return;

        m_break = 1;
        m_ss.close();
        wait2();
    }


}


/**
 *
 * <p>Title: </p>
 *
 * <p>Description: </p>
 *
 * <p>Copyright: Copyright (c) 2007</p>
 *
 * <p>Company: </p>
 *
 * @author not attributable
 * @version 1.0
 */
class ServerSocket_GarbageThread extends NqThreadX {

    public ServerSocket_GarbageThread() {
        m_break = 0;
    }

    public int startUp() {
        m_break = 0;
        return start();
    }

    public void cleanUp() {
        m_break = 1;
        wait2();
    }

    Object parentClass = null;
    int m_break = 0;


    public void run2() {
        while (m_break == 0) {

            NqSocketServer ss = (NqSocketServer) parentClass;

            ss.garbage();

            ThreadX.sleep(100);
        }
    }

}


/**
 *
 * <p>Title: </p>
 *
 * <p>Description: </p>
 *
 * <p>Copyright: Copyright (c) 2007</p>
 *
 * <p>Company: </p>
 *
 * @author not attributable
 * @version 1.0
 */


final public class NqSocketServer extends NqThreadX implements ServerSocketInterface { //, public NqEventManagerClass


    public NqSocketServer() {

        // addIpMask("*.*.*.*"); //ipmask:all allow~

        m_break = 0;
        m_max_buffer_size = 1024*8;//256k (max data collect able size )
        m_max_client_count = 1024;//1024 clients
        m_resend_interval = (int) (1.5 * 1000); //1.5 second (it auto repair)
        m_send_timeout = (30 * 1000); //15 second


        m_gt.parentClass = this;
    }

    private NqEventManagerClass myEventMgr = new NqEventManagerClass();


    protected Object syncClientLock = new Object(); //lang__criticalsection syncClientLock;


    protected ArrayList<ClientSocket> m_clients = new ArrayList<ClientSocket>(); //CArray<ClientSocket*,ClientSocket*> m_clients;
    //protected HashMap<Socket,ClientSocket> m_clients=new HashMap<Socket,ClientSocket>();


    protected int m_resend_interval;



    //recv
    protected Object m_syncRecvLock = new Object();


    protected wserver_socket m_svr_sk = new wserver_socket();
    protected int m_break;
    protected int m_max_buffer_size;
    protected int m_max_client_count;
    protected long m_send_timeout;


    protected ServerSocket_GarbageThread m_gt = new ServerSocket_GarbageThread();

    public long recevie_time_out=0;


    public void run2() {
        //debug("serversocket v2:run2");
        while (m_break == 0) {

            if (m_svr_sk.m_port_number != 0) {

                Socket sk = m_svr_sk.accept_from_client();
                if (sk == null) {
                    m_break = 1;
                    continue;
                }

                if (clientCount() > this.m_max_client_count) {
                    super.closesocket(sk);
                    continue;
                }



                //add socket
                {
                    //lang__blockLock bl(&m_lock);//lock <---
                    ClientSocket nsk = new ClientSocket("def-accept-sk");
                    nsk.m_max_buffer_size = this.m_max_buffer_size;
                    nsk.m_interface = this;
                    nsk.m_ss.accept(sk);
                    nsk.start();
                    addClient(nsk);
                }

                //accept event
                {
                    NqEventClass ev = new NqEventClass();
                    ev.msg = "accept";
                    ev.sk = sk;
                    ev.sk_str=sk.getRemoteSocketAddress().toString();
                    //ev.event_str=ustring::format("%s:%d", m_ss.m_previous_accept_addr.cpt(), m_ss.m_previous_accept_port ).cpt();
                    myEventMgr.addEvent(ev);
                }

            } //m_ss.alive?

            ThreadX.sleep(1);
        } //while

        //accept event
        {
            NqEventClass ev = new NqEventClass();
            ev.msg = "close:server";
            ev.sk = null;
            //ev.event_str=ustring::format("%s:%d", nsk.m_ss. );
            myEventMgr.addEvent(ev);
        }
    }




    public void setMaxClientCount(int n) {
        m_max_client_count = n; //cnt
    }
    public void setMaxBufferSize(int n) {
        m_max_buffer_size = n; //bytes
    }
    public void setTimeOut(int n) {
        m_send_timeout = n; //milli second
    }



    /**
     *
     * @param port int
     * @param maxClientCount int
     * @param maxBufferSize int
     * @param sendTimeOut int
     * @param resendTimeInterval int
     * @param maxEventBufferSize int
     * @return int
     */
    private Object m_onePlay = null;
    public int startUp(
            int port
            ) {

        if (m_onePlay != null) //only one time use~
            return 0;


        if (port != 0) { //he desn't like the accept
            if (m_svr_sk.start(port) == 0) {
                m_svr_sk.close();
                return 0;
            }
        } else {
            //System.out.println("NqSocketServer: no server ");
        }

        m_onePlay = new Object();
        start(); //thread start
        m_gt.startUp();
        return 1;
    }


    /**
     *  support old (template using)
     * @param port int
     * @param mcc int
     * @param mbs int
     * @param sto int
     * @param nouse int
     * @param mebs int
     * @return int
     */
    public int startUp(
            int port
            , int mcc
            , int mbs
            , int sto
            , int nouse //resendTimeInterval
            , int nouse2 //max event buffer size
            ) {

        setMaxClientCount(mcc);
        setMaxBufferSize(mbs);
        setTimeOut(sto);
        //setMaxEventBufferSize(mebs);

        return startUp(port);
    }


    /**
     *
     */
    public void cleanUp() {
        //lang__blockLock bl(&m_lock);//lock <---
        //debug("cleanup");
        m_break = 1;
        m_svr_sk.close();
        m_gt.cleanUp();
        wait2();
        close();
        m_onePlay = null;

        while (m_clients.size() > 0) {
            ClientSocket csk = m_clients.get(0);
            csk.cleanUp();
            removeClient(0);
        } //while

        myEventMgr.clear();
        //debug("cleanup-2");
    }

    /**
     *
     * @return int
     */
    //use any ontimer
    //private int garbage_client_idx=0;
    public int garbage() {
        //synchronized(syncClientLock) {//lock <---
        //debug("garbage...");
        synchronized (syncClientLock) {
            //debug("garbage...2");

            if (m_svr_sk.alive() == false && m_svr_sk.m_port_number != 0) {
                return 0;
            }

            int cnt = m_clients.size();
            int p = 0;

            for (int i = 0; i < cnt; i++) {

                ClientSocket sk = m_clients.get(p);



                if (sk.m_ss.alive() == false || sk.m_close_reserve == 1) {

                    Socket sock1 = sk.m_ss.getHandle();

                    String sk_str=sock1.getRemoteSocketAddress().toString();


                    //match code in : removeClient
                    {
                        ClientSocket sk1 = m_clients.get(p);
                        m_clients.remove(p);
                        sk1.cleanUp();
                        //delete sk;
                    }

                    //add event
                    {
                        NqEventClass ev = new NqEventClass();
                        ev.msg = "close";
                        ev.sk = sock1;
                        ev.sk_str=sk_str;
                        myEventMgr.addEvent(ev);
                    }

                } else
                    p++;



                /*
                //time out ( close at next time )
                if (this.recevie_time_out != 0) {
                    if ((System.currentTimeMillis() - sk.last_receive_time) > this.recevie_time_out) {

                        NqEventClass ev = new NqEventClass();
                        ev.msg = "err:recv time out";
                        ev.sk = sk.m_ss.getHandle();
                        myEventMgr.addEvent(ev);

                        //sk.m_ss.close();//to close reserve
                        sk.m_close_reserve = 1;

                    }
                }
                */

               //why we dont' check the disconnect??
               //System.out.println("it can be not bad! send test byte~");
               try {
                   byte[]r1=new byte[]{'c',0,0,0};
                   byte[] b = NqStreamPacketHeader.writeBytes("ulib-nr", null, 0, 0,r1);
                   Socket s = sk.m_ss.getHandle();
                   s.getOutputStream().write(b);
                   s.getOutputStream().flush();
               } catch (Exception e1) {
                   //disconnect
                   sk.m_close_reserve = 1;
               }





            } //while

            return 1;
        }

    }


    /**
     *
     * @param ip String
     * @param port int
     * @return Socket
     */

    public Socket connect(String ip, int port, String name) {

        if (clientCount() > this.m_max_client_count) {
            System.out.println("connect:err:client count over!");
            return null;
        }
        //lang__blockLock bl(&m_lock);//lock <---

        ClientSocket nsk = new ClientSocket(name);

        nsk.m_max_buffer_size = this.m_max_buffer_size;
        nsk.m_interface = this;
        if (nsk.m_ss.connect(ip, port) == 0) {
            nsk.m_ss.close();
            // delete nsk;
            return null;
        }

        nsk.start();
        Socket sk = nsk.m_ss.getHandle();
        addClient(nsk);

        NqEventClass ev = new NqEventClass();
        ev.msg = "connected";
        ev.sk = sk;
        ev.sk_str=sk.getRemoteSocketAddress().toString();
        myEventMgr.addEvent(ev);

        return sk;
    }


    /**
     *
     * @return int
     */
    public int clientCount() {
        synchronized (syncClientLock) { //lock <---
            //debug("garbage...2");
            return m_clients.size();
        }
    }

    /**
     *
     * @param nsk ClientSocket
     * @return int
     */
    public int addClient(ClientSocket nsk) {
        synchronized (syncClientLock) { //lock <---
            //debug("add...2");

            nsk.m_max_buffer_size = this.m_max_buffer_size; //set max buffer size

            if (m_clients.size() > m_max_client_count) {
                //error: error on before thread runing.. because delete nsk;
                //
                //nsk.cleanUp();
                //delete nsk;
                //return 0;
                nsk.m_close_reserve = 1;
            }

            m_clients.add(nsk);
            return 1;
        }
    }


    /**
     *
     * @param p int
     * @return int
     */
    public int removeClient(int p) {
        synchronized (syncClientLock) { //lock <---
            //debug("remove...2");

            int cnt = m_clients.size();
            if (p >= cnt)
                return 0;

            ClientSocket sk = m_clients.get(p);
            m_clients.remove(p);
            sk.cleanUp();
            //delete sk;

            return 1;
        }
    }


    /**
     *
     * @param p int
     * @return Socket
     */
    public Socket getClient(int p) {
        synchronized (syncClientLock) { //lock <---
            int cnt = m_clients.size();
            if (p < 0 || p >= cnt)
                return null;

            return m_clients.get(p).m_ss.getHandle();
        }
    }

    /**
     *
     * @param ipname String
     * @return ClientSocket
     */
    public Socket getClient(String name) {
        ClientSocket cl = getClientSocket(name);
        if (cl == null)
            return null;
        return cl.m_ss.getHandle();
    }

    /**
     *
     * @param name String
     * @return Socket
     */
    private ClientSocket getClientSocket(String name) {
        if (name.trim().length() == 0)
            return null;

        synchronized (syncClientLock) { //lock <---
            int cnt = m_clients.size();
            for (int i = 0; i < cnt; i++) {
                if (m_clients.get(i).m_name.equals(name)) {
                    return m_clients.get(i);
                } //if
            } //for
        }
        return null;
    }

    /**
     *
     * @param name String
     * @return ClientSocket
     */
    private ClientSocket getClientSocket(Socket sk) {
        if (sk == null)
            return null;

        synchronized (syncClientLock) { //lock <---
            int cnt = m_clients.size();
            for (int i = 0; i < cnt; i++) {
                if (sk.equals(m_clients.get(i).m_ss.getHandle()) == true) {
                    return m_clients.get(i);
                }
            }
        }
        return null;
    }


    /**
     *
     * @param ipname String
     * @param sndBuf byte[]
     * @param sndLen int
     * @param recvBuf byte[]
     * @param recvLen int
     * @return int
     */
    public int sendStream
            (
                    String ipname,
                    byte[] sndBuf,
                    int sndLen,
                    byte[] recvBuf,
                    int recvLen
            ) {

        ClientSocket cl = getClientSocket(ipname);
        if (cl == null)
            return 0;

        synchronized (syncClientLock) { //lock <---

            return cl.m_sscls.sendStream(
                    cl.m_ss.getHandle(),
                    sndBuf,
                    sndLen,
                    recvBuf,
                    recvLen,
                    this.m_send_timeout
                    );
        }
    }


    /**
     *
     * @param sk Socket
     * @param sndBuf byte[]
     * @param sndLen int
     * @param recvBuf byte[]
     * @param recvLen int
     * @return int
     */
    public int sendStream
            (
                    Socket sk,
                    byte[] sndBuf,
                    int sndLen,
                    byte[] recvBuf,
                    int recvLen
            ) {

        ClientSocket cl = getClientSocket(sk);
        if (cl == null)
            return 0;

        synchronized (syncClientLock) { //lock <---

            return cl.m_sscls.sendStream(
                    sk,
                    sndBuf,
                    sndLen,
                    recvBuf,
                    recvLen,
                    this.m_send_timeout
                    );
        }
    }


    /**
     *
     * @param sk Socket
     * @param buf byte[]
     * @param s int
     * @return int
     */
    public int setReturnValue(Socket sk, byte[] buf, int s) {

        ClientSocket cl = getClientSocket(sk);
        if (cl == null)
            return 0;

        synchronized (syncClientLock) { //lock <---
            return cl.m_sscls.setReturnValue(buf, s);
        }
    }


    /**
     *
     * @param cls Object
     * @param sk Socket
     * @param buf byte[]
     * @param len int
     * @return int
     */
    public synchronized int event_recv_Cs(Object cls, Socket sk, byte[] buf,
                                          int len) {
        //debug("event_recv_Cs>>>");
        synchronized (m_syncRecvLock) {

            ClientSocket cli = (ClientSocket) cls;


            //debug("event_recv_Cs>>>2");
            NqEventClass ev = new NqEventClass();

            int rr = cli.m_sscls.recvStream(sk, buf, len, ev);
            //System.out.println("v2-----res----------"+rr);


            if (rr == 0)
                return 0;


            //ev1
            if (ev.msg.length() != 0) {
                // debug("recv data size={0}", rr);

                /*
                if (ev.len == 5 &&
                    ev.buf[0] == 0 &&
                    ev.buf[1] == (byte) 'p' &&
                    ev.buf[2] == (byte) 'i' &&
                    ev.buf[3] == (byte) 'n' &&
                    ev.buf[4] == (byte) 'g'
                        ) {

                    debug("internal reserve:ping");
                    //send return
                    byte[] bs = ByteArrayUtil.getBytes(0, "ping:return");
                    cli.m_sscls.setReturnValue(bs, bs.length);

                } else if (ev.len != 0) {
                */
                    myEventMgr.addEvent(ev);
                //}


            } else {
                //delete ev;
            }

            return 1;
        } //sync
    } //method


    /**
     *
     */
    public void closeAllSockets() {
        for (int i = 0; i < clientCount(); i++) {

            Socket sk = getClient(i);
            if (sk != null) {
                try {
                    sk.close();
                } catch (Exception e) {
                    ;
                }
            }
        } //for
    }


    /**
     *
     * @return int
     */
    public int getEventCount() {
        return myEventMgr.getEventCount();
    }


    public NqEventClass popAEvent() {
        return myEventMgr.popAEvent();
    }


    @Deprecated
    public int getEventBufferLength() {
        return 0;//support old
    }


    /*
         HashMap<String, String> myIpMasks = new HashMap<String, String>();
         public void addIpMask(String s) {
        if (myIpMasks.get(s) == null) {
            myIpMasks.put(s, s);
        }
         }

         public void removeIpMask(String s) {
        myIpMasks.remove(s);
         }

         public void clearIpMask() {
        myIpMasks = new HashMap<String, String>();
         }
     */

    public static int ip_mask(String[] masks, String szIp) {

        String[] ipl = ustring.split(szIp, "./:");

        //Object[] masks = myIpMasks.values().toArray();

        for (int i = 0; i < masks.length; i++) {
            String s = masks[i].toString();

            String[] maskl = ustring.split(s, "./:");
            if (maskl.length > 4) {
                continue;
            }
            if (
                    (maskl[0].equals("*") || maskl[0].equals(ipl[0])) &&
                    (maskl[1].equals("*") || maskl[1].equals(ipl[1])) &&
                    (maskl[2].equals("*") || maskl[2].equals(ipl[2])) &&
                    (maskl[3].equals("*") || maskl[3].equals(ipl[3]))) {
                return 1;
            }

        }
        return 0;
    }


    /**
     *
     * @return int
     */
    public long getSendTimeOut() {
        return m_send_timeout;
    }
    /**
     *
     * @param svr NqSocketServer
     * @param sk Socket
     * @return double
     */
    /*
    public static double pingTo(NqSocketServer svr, Socket sk,int retry) {
        double total = 0;
        for (int i = 0; i < retry; i++) {
            long st = System.currentTimeMillis();
            byte[] rbuf = new byte[1024];
            //byte[] sbuf = NetFileServer.sendMsgToBytes(0, "ping");
            byte[] sbuf = new byte[5];
            sbuf[0] = 0;
            sbuf[1] = (byte) 'p';
            sbuf[2] = (byte) 'i';
            sbuf[3] = (byte) 'n';
            sbuf[4] = (byte) 'g';

            long recvLen = svr.sendStream(sk, sbuf, sbuf.length, rbuf, rbuf.length);
            if (recvLen <= 0) {
                return 8; //killo bytes
            }
            long et = System.currentTimeMillis();
            total += (double) (et - st); //50 is pop time~
        }
        total /= 4;

        return total;
    }
   */

    /**
     *
     * @return boolean
     */
    public boolean alive() {
        return ((m_svr_sk.alive() == true || m_svr_sk.m_port_number == 0) && m_break == 0);
    }

    /**
     *
     * @param n long
     */
    public void setReceiveTimeOut(long milli_second) {
        recevie_time_out=milli_second;
    }
} //class
